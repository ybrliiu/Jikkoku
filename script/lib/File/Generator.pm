package File::Generator {

  use v5.24;
  use Mouse;
  use Carp qw/croak/;
  use Config::PL;
  use Path::Tiny;

  use constant HISTORY_FILE => 'generate_file.db';

  has 'store_path'   => (is => 'rw', isa => 'Str', default => './');
  has 'watch_files'  => (is => 'rw', isa => 'ArrayRef', default => sub { +[] });
  has 'process_list' => (is => 'rw', isa => 'HashRef', default => sub { +{} });

  sub register {
    my ($self, $app) = @_;
    $app->helper(generate_file => sub {
      my $c = shift;
      return __PACKAGE__->new(@_);
    });
  }

  sub set_process {
    my ($self, $file_name, $callback) = @_;
    croak "few arguments to subroutine (@_) " if @_ < 3;
    croak "please specify CodeRef" unless ref $callback eq 'CODE';

    $self->{process_list}{$file_name} = $callback;
    return $self;
  }

  sub generate {
    my ($self) = @_;

    # load history data
    my $history_file_path = $self->{store_path} . HISTORY_FILE;
    my $history_file      = path( $history_file_path );
    unless ( $history_file->exists ) {
      $history_file->touch;
      $history_file->spew_utf8("{}");
    }
    my $history      = config_do( $history_file_path );
    my $history_data = <<"EOS";
# manege file of generate file from perl
# this file is generated by @{[ __PACKAGE__ ]}. Don't edit this file;

{
EOS

    # edit files
    my @watch_files_mtime = map { path( $_ )->stat->mtime } @{ $self->{watch_files} };
    while ( my ($key, $value) = each %{ $self->{process_list} } ) {
      my $last_update_time = $history->{$key}{mtime} // 0;
      my $file             = path( $self->{store_path} . $key );
      $file->touch unless $file->exists;
      my $spew_content = $value->();
      if ( length $spew_content != length $file->slurp
          || grep { $last_update_time < $_ } @watch_files_mtime ) {
        $file->touch unless $file->exists;
        $file->spew( $spew_content );
      }
      $history_data .= <<"EOS";
  '$key' => {
    name  => '$key',
    mtime => @{[ $file->stat->mtime ]},
  },
EOS
    }
    
    # save history
    $history_data .= "\n} \n";
    $history_file->spew( $history_data );
  }

}

1;

=encoding utf8

=head1 NAME
  
  File::Generator - new module

=head1 SYNOPSIS

  use File::Generator;
  
  my $generator = File::Generator->new;
  $generator->set_process('test.txt' => sub {
    # 出力したい文字列を最後に返す
    "I am write to test.text!!\n";
  });
  $generator->generate;

  $ cat test.txt
  I am write to test.text!!

=head1 ATTRIBUTES

=head2 store_path
  
  生成するファイルを保存するパスです。

=head2 watch_files [ArrayRef[Str]]
  
  監視するファイルを指定します。
  監視しているファイルが前に生成したファイルより後に更新されていれば、
  生成するファイルを再生成します。

=head1 METHOD

=head2 generate
  
  引数 : file_name[Str], process[CodeRef]
  set_process で渡されたクロージャの最後に評価した値を、指定されたファイルに出力します。
  ファイルが生成される条件は以下の通りです : 
  出力しようとしたデータが以前に出力されたデータと違う
  watch_files に指定されているファイルが以前生成されたファイルより後に更新されている時

  NOTE : watch_files 別にいらなくね...?

=cut

